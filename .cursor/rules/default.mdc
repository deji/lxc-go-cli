---
alwaysApply: true
---

# Cursor project rules for the lxc-go-cli CLI (Go)
# - Place as: .cursor/rules
# - Keep concise actionable instructions for the assistant/AI in Cursor.

project: lxc-go-cli
purpose: >
  Help maintainers implement, test and review code for the lxc-go-cli CLI (golang).
  Tests are the source of truth; developer will manually run real LXC builds as lxc/lxd is not available on the development machine.

rules:
  - id: testing-policy
    scope: repo
    instruction: >
      All code changes must include unit tests that cover happy-path and error-path behaviour.
      The repo must maintain >= 80% overall test coverage. Prefer unit tests over integration tests;
      integration tests must use mocks/stubs because LXC is not present on the dev machine.
      When adding an integration-style test, it must explicitly use generated mocks (see mock-generation rule).
      When verifying coverage in CI or locally, fail the job if coverage < 80%.

  - id: test-structure
    scope: repo
    instruction: >
      Organise tests next to code (pkg/foo/foo_test.go). Use table-driven tests for combinatorial behaviour.
      Keep pure unit tests fast (<50ms typical) and isolated from OS/network resources.

  - id: mock-generation
    scope: repo
    instruction: >
      Use interface-based design for external dependencies (LXC client, filesystem, network).
      Prefer generated mocks:
        - Option A (recommended for ergonomics): generate testify-compatible mocks via mockery:
            //go:generate mockery --name=MyInterface --output=mocks --dir=./pkg/... --filename=mock_myinterface.go
        - Option B (when needing strict interaction expectations): use golang/mock (mockgen).
      Commit generated mocks to the repo under /mocks or keep them in test-only files (mocks_test.go).
      Run go:generate in CI for regeneration checks.

  - id: recommended-libs
    scope: repo
    instruction: >
      Use well-maintained libraries where they make sense:
        - CLI: spf13/cobra (command structure + cobra-cli generator).
        - Config (only if needed): spf13/viper.
        - Testing: stretchr/testify (assert & mock helper).
        - Mock generation: vektra/mockery or golang/mock.
        - Test runner/formatting: gotest.tools / gotestsum for nicer output.
        - Lint/quality: golangci-lint.
      Do not invent custom HTTP/LXC shims when a safe interface + mocks suffice. :contentReference[oaicite:1]{index=1}

  - id: coverage-enforcement
    scope: repo
    instruction: >
      Local check (developer):
        go test ./... -coverprofile=coverage.out || exit 1
        go tool cover -func=coverage.out | awk '/total/ {print $3}' | sed 's/%//' | \
          awk '{if($1<80) {print "COVERAGE FAIL: " $1 "%"; exit 1} else {print "COVERAGE OK: " $1 "%"}}'
      CI snippet:
        - run: go test ./... -coverprofile=coverage.out
        - run: COVER=$(go tool cover -func=coverage.out | awk '/total/ {print $3}' | sed 's/%//'); \
               if [ "$(printf "%.0f" $COVER)" -lt 80 ]; then echo "Coverage $COVER% < 80%"; exit 1; fi

  - id: integration-tests
    scope: repo
    instruction: >
      Integration tests must:
        - Use generated mocks to simulate LXC client behaviour (failures, timeouts, state transitions).
        - Validate command wiring, CLI flags parsing, and high-level orchestration (not system LXC runtime).
        - Use temporary directories (t.TempDir()) and deterministic test data.
        - Mark long-running or environment-dependent tests with build tags (// +build integration) so CI can opt-in/out.

  - id: docs-and-context7
    scope: repo
    instruction: >
      When the assistant needs external docs, always use the Context7 MCP server to fetch the latest official docs and best-practices before making recommendations.
      Suggested MCP install command to add to the agent/tools list:
        npx -y @upstash/context7-mcp@latest
      The assistant should explicitly cite Context7 results when it used them. :contentReference[oaicite:2]{index=2}

  - id: ci-and-tooling
    scope: repo
    instruction: >
      CI must run: golangci-lint, go vet, go test (with coverage), and go generate for mocks.
      Provide a Makefile targets:
        make test => runs unit tests
        make coverage => runs coverage check and prints result
        make mocks => runs go:generate
        make lint => runs golangci-lint run ./...
      Use go.mod and pinned versions for reproducible builds.

assistant-behaviour:
  - discuss_and_review_changes_before_making_them: true
  - be_concise_by_default: true
  - avoid_repetition: true
  - prefer_testing_over_manual_verification: true
  - when_in_doubt_use_context7: true
  - always_propose_existing_solution_first: true
